---
title: "Results"
format: 
  docx:
    reference-doc: figures-doc.docx
    keep-md: false
    fig-format: svg
crossref:
  fig-title: '**Figure**'
  fig-labels: arabic
  tbl-title: '**Table**'
  tbl-labels: arabic
  title-delim: ":"
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(dev = "cairo_pdf")
knitr::opts_chunk$set(fig.path="figures/", echo = FALSE)
```




```{r}
#| echo: false
#| message: false
library(ggplot2)
library(data.table)
source("code/plot-functions.R")
library(gridExtra)

# Function to extract the legend as a grob
get_legend <- function(ggplot_obj) {
  # Build the gtable
  plot_gtable <- ggplot_gtable(ggplot_build(ggplot_obj))
  
  # Find the index of the guide box (the legend)
  guide_index <- which(sapply(plot_gtable$grobs, function(x) x$name) == "guide-box")
  
  # Return the legend grob
  if (length(guide_index) > 0) {
    return(plot_gtable$grobs[[guide_index]])
  } else {
    warning("No legend found.")
    return(NULL)
  }
}

```

## Results

### Model fit

```{r}
#| echo: false
#| message: false

chosen_scale = "pft-period7-25patches"

fig3models <- c(
    list.files("results/02_realdata/", full.names = T, recursive = T, pattern = chosen_scale),
    list.files("results/02_realdata_hybridTF0/", full.names = T, recursive = T, pattern = chosen_scale)
)

## create fit simulations
fig3models_fit <- fig3models[grepl("S0_T0",fig3models)]
fit_process = build_model_dt(pt_file = fig3models_fit[1])[[1]]
fit_hybrid = build_model_dt(pt_file = fig3models_fit[2])[[1]]
all_dt = rbind(
  data.table(fit_process[test_train == "train"], type = "process"),
  data.table(fit_hybrid[test_train == "train"], type = "hybrid")
)
period_length = unique(all_dt[!is.na(period_length)]$period_length)
all_dt <- all_dt[,-c("period_length")]

### species to pft
# species_dt <- fread("data/BCI/data-cleaning/genus/species_assigned.csv")
# all_dt2 <- merge(all_dt, unique(species_dt[,.(species = speciesID, pft = PFT_2axes)]), by = "species", all.x = T, allow.cartesian = T)
# all_dt2[,species := pft,]
# all_dt2 <- all_dt2[,-c("pft")]
# all_dt2[,.(
#   ba.pred = sum(ba.pred, na.rm = T),
#   ba.obs = sum(ba.obs, na.rm = T),
#   trees.pred = sum(trees.pred, na.rm = T),
#   trees.obs = sum(trees.obs, na.rm = T),
#   dbh.pred = sum(dbh.pred*trees.pred, na.rm = T)/sum(trees.pred, na.rm = T),
#   dbh.obs = sum(dbh.obs*trees.obs, na.rm = T)/sum(trees.obs, na.rm = T),
#   growth.pred = sum(growth.pred*trees.pred, na.rm = T)/sum(trees.pred, na.rm = T),
#   growth.obs = sum(growth.obs*trees.obs, na.rm = T)/sum(trees.obs, na.rm = T),
#   mort.pred = sum(mort.pred*trees.pred, na.rm = T)/sum(trees.pred, na.rm = T),
#   mort.obs = sum(mort.obs*trees.obs, na.rm = T)/sum(trees.obs, na.rm = T),
#   reg.pred = sum(reg.pred*trees.pred, na.rm = T)/sum(trees.pred, na.rm = T),
#   reg.obs = sum(reg.obs*trees.obs, na.rm = T)/sum(trees.obs, na.rm = T)
# ), by = .(siteID,year,species,test_train, type)]
# ###



all_dt2 <- melt(all_dt, id.vars = c("type","siteID","year","species","test_train"))
all_dt2[grepl("pred",variable), pred_obs := "pred",]
all_dt2[grepl("obs",variable), pred_obs := "obs",]
all_dt2[, variable := gsub(".obs|.pred","",variable),]

p_dat <- all_dt2[test_train == "train",.(value = mean(value,na.rm = T)), by = .(type,year,species,test_train, pred_obs, variable)]
p_dat2 <- p_dat[!is.na(value)]

p_dat2_all <- 
  rbind(
    p_dat2[variable %in% c("ba", "trees"),.(
      value = sum(value, na.rm = T),
      species = "all"
    ), by = .(type, year, test_train, pred_obs, variable)],
    p_dat2[variable %in% c("dbh", "reg","growth","mort"),.(
      value = mean(value, na.rm = T),
      species = "all"
    ), by = .(type, year, test_train, pred_obs, variable)]
  )

p_dat2 <- rbind(
  p_dat2,
  p_dat2_all
)

p_dat2[variable %in% c("ba", "trees"), value := value/0.1,]
p_dat2[variable %in% c("mortality", "growth"), value := value/5*100,]



# create cv simulations
fig3models_cv <- fig3models[!grepl("S0_T0",fig3models)]
# fig3models_cv <- fig3models[!grepl("S0_T0",fig3models) & grepl("T0",fig3models)]

cors_fullPlot = fread("results/cors_fullPlot.csv")
cors_fullPlotSpecies <- fread("results/cors_fullPlotSpecies.csv")

all_cors <- rbind(
  data.table(cors_fullPlot, species = "all"),
  cors_fullPlotSpecies
)

all_cors <- all_cors[scale == chosen_scale & grepl("T0", cv),]
all_cors[data == "02_realdata_hybridTF1",type := "hybrid",]
all_cors[data == "02_realdata",type := "process",]
all_cors[, type := factor(type, levels = c("process", "hybrid"), ordered = T),]
all_cors <- all_cors[!is.na(type)]
all_cors[,species := factor(species, levels = c(sort(unique(all_cors$species)))),]

```

```{r}
#| label: fig-Fig_3
#| fig-format: svg
#| fig-width: 13
#| fig-height: 10
#| echo: false
#| silent: true
#| message: false
#| warning: false
#| fig-cap: "Observed and predicted forest structure and demographic rates for five PFTs. a) and b) display the observed values (straight line & crosses) vs the predicted values from the process model (dashed line & circles) and the hybrid model (dotted line & triangles), respectively. c) shows the absolute difference between the observed values and the predictions of the process and hybrid model. d) shows the calculated pearson correlation from the five-fold blocked spatial cross-validation. The first two rows show the observed and predicted values for basal area and tree density. The third and fourth row show the observed and predicted values for diameter at breast height (dbh), regeneration, growth, and mortality."


vars = c("ba", "trees", "dbh", "reg","growth","mort")
var_labels <- c(
  expression(basal~area~(m^2~ha^-1)),
  expression(trees~(ha^-1)),
  expression(dbh~(cm)),
  expression(regeneration~(ha^-1)),
  expression(growth~(m^3~ha^-1~yr^-1)),
  expression(mortality~(m^3~ha^-1~yr^-1))
)
var_labels2 <- c(
  "basal~area~(m^2~ha^-1)",
  "trees~(ha^-1)",
  "dbh~(cm)",
  "regeneration~(ha^-5)",
  "growth~('%'~yr^-1)",
  "mortality~('%'~yr^-1)"
)
p_dat2[,variable2 := factor(
  variable, 
  levels = vars,
  labels = var_labels2),]

p_dat2[, pred_obs2 := factor(pred_obs, levels = c("obs","pred"), labels = c("observation","prediction")) ,]

if(grepl("period35",chosen_scale)){
  p_dat2[, year2 := 1984+year,]
}else{
  p_dat2[, year2 := 1985+year*5,]
}

p_dat2cast <- dcast(p_dat2, type + year2 + variable2 + species ~ pred_obs2, value.var = "value")
p_dat2[,type2 := type,]
p_dat2[pred_obs == "obs",type2 := "observation",]
p_dat2[,type2 := factor(type2, levels = c("observation", "process", "hybrid"), 
                        labels = c("Observed", "Predicted (Process Model)", "Predicted (Hybrid Model)")),]
unique(p_dat2$type2)
p1_legende_basis =
  ggplot(p_dat2, aes(x = year2, y = value)) +
  geom_point(aes(shape = type2, color = factor(species)), size = 3) +
  geom_line(aes(linetype = type2, color = factor(species))) +
  scale_shape_manual(values = c(4, 1, 2)) +
  scale_linetype_manual(values = c("solid", "dashed", "dotted")) +
  scale_color_manual(name = "PFT", values = c(scales::hue_pal()(5), "black"))+
  theme_classic()+
  theme(
      strip.placement = "outside",        # place strip label fully outside the panel
      strip.background = element_blank(),     # Remove the facet label box
      strip.text.y    = element_text(angle = 0),
      strip.text.x = element_blank(),
      legend.position = "bottom",
      legend.title.position = "left"
    ) +
    guides(
      shape = guide_legend(position = "bottom", direction = "vertical", title = "Observation / Model Type"),
      linetype = guide_legend(position = "bottom",direction = "vertical", title = "Observation / Model Type")
      )

p_list <- list()
for(j_type in c("process","hybrid")){
  i_pdat = p_dat2[type == j_type,]
  j_linetype = ifelse(j_type == "process", "dashed", "dotted")
  j_pointtype = ifelse(j_type == "process", 1, 2)
  p1 =
    ggplot(i_pdat, aes(x = year2, y = value)) +
    geom_point(aes(shape = pred_obs2, color = factor(species)), size = 3) +
    geom_point(data = p_dat2[type != j_type,], aes(x = year2, y = value), color = NA)+
    geom_line(aes(linetype = pred_obs2, color = factor(species))) +
    scale_shape_manual(values = c(4,j_pointtype)) +
    scale_linetype_manual(values = c("solid", j_linetype)) +
    facet_wrap(
      ~ variable2,
      scales        = "free_y", # keep each facet's y-scale
      ncol          = 1,        # stack facets vertically
      strip.position = "left",   # move strips from top to the left
      labeller = label_parsed
    ) +
    scale_color_manual(name = "PFT", values = c(scales::hue_pal()(5), "black")) +
    theme_classic() +
    labs(x = "Inventory Period", y = NULL) + # remove the default y label
    theme(
      strip.placement = "outside",        # place strip label fully outside the panel
      strip.background = element_blank(),     # Remove the facet label box
      strip.text.y    = element_text(angle = 0),
      strip.text.x = element_blank(),
      axis.title.x = element_blank(),
      legend.position = "bottom"
    ) +
    guides(
      shape = guide_legend(title = element_blank(), direction = "vertical"),
      linetype = guide_legend(title = element_blank(), direction = "vertical")
      )+
    scale_x_continuous(breaks = seq(min(i_pdat$year2), max(i_pdat$year2), by = 5))
    p_list[[j_type]][["lineplot"]] <- p1+theme(legend.position = "none")
}
p1b = ggplot(p_dat2cast[!is.na(observation)], aes(x = year2, y = prediction-observation)) +
  geom_hline(yintercept = 0, linetype = "solid", color = "grey50", linewidth = 1)+
  geom_point(aes(shape = type, color = factor(species)), size = 3) +
  # geom_point(data = p_dat2[type != j_type,], aes(x = year2, y = value), alpha = 0.1)+
  geom_line(aes(linetype = type, color = factor(species))) +
  scale_shape_manual(values = c(process = 1, hybrid = 2)) +
  scale_linetype_manual(values = c(process = "dashed", hybrid = "dotted"))+
  facet_wrap(
    ~ variable2,
    scales        = "free_y", # keep each facet's y-scale
    ncol          = 1,        # stack facets vertically
    strip.position = "left",   # move strips from top to the left
    labeller = label_parsed
  ) +
  scale_color_manual(name = "PFT", values = c(scales::hue_pal()(5), "black")) +
  theme_classic() +
  labs(x = "Inventory Period", y = NULL) + # remove the default y label
  theme(
    strip.placement = "outside",        # place strip label fully outside the panel
    strip.background = element_blank(),     # Remove the facet label box
    strip.text.y    = element_text(angle = 0),
    strip.text.x = element_blank(),
    axis.title.x = element_blank(),
    legend.position = "bottom"
  ) +
  guides(
    shape = guide_legend(title = element_blank(), direction = "vertical"),
    linetype = guide_legend(title = element_blank(), direction = "vertical")
  )+
  scale_x_continuous(breaks = seq(min(p_dat2cast$year2), max(p_dat2cast$year2), by = 5))
p1b_legend = get_legend(p1b)
p1b = p1b+theme(legend.position = "none")
all_cors[,type2 := factor(type, levels = c("process", "hybrid"), labels = c("Process", "Hybrid")),]
p2 = 
ggplot(all_cors, aes(x = type2, y = spearmans_r, color = species))+
  geom_hline(yintercept = c(-1,0,1), linetype = "solid", color = "grey50", linewidth = 1)+
  geom_boxplot(position = position_dodge())+
  labs(x = "", y = "Spearmans R")+
  theme_classic()+
  facet_wrap(~variable, ncol = 1)+
  coord_cartesian(ylim = c(-1,1))+
  # fully remove stip
  theme(strip.background = element_blank(),
        strip.text.x = element_blank(),
        strip.text.y = element_blank(),
        axis.title.x = element_blank(),
        legend.position = "bottom")+
  #move y axis from left side to right side
  scale_y_continuous(position = "right", breaks = c(-1,0,1))+
  scale_color_manual(name = "PFT", values = c(scales::hue_pal()(5),"black"))

p_list[["cv_cor"]] <- 
  p2+theme(
    legend.position = "none"
    )
  
p1_legend <- get_legend(p1)
p2_legend <- get_legend(p2)
p1to3_legend <- get_legend(p1_legende_basis)
# load package for textGrob
library(grid)
label_grob_f = function(x){
  textGrob(x, x = unit(0.05, "npc"), y = unit(0.95, "npc"), just = c("left", "top"), gp = gpar(fontsize = 16, fontface = "bold"))
}

gridExtra::grid.arrange(
  grobs = list(
    label_grob_f("a"), label_grob_f("b"), label_grob_f("c"), label_grob_f("d"),
    p_list$process$lineplot, p_list$hybrid$lineplot, p1b, p_list$cv_cor,
    p1to3_legend
    ), 
  layout_matrix = rbind(
    c(1,2,3,4),
    c(5,6,7,8),
    c(9,9,9,9)),
  # include letters to each plot
  widths = c(0.6,0.6,0.6,0.4), 
  heights = c(0.05,0.95,0.15))

```


```{r}
#| label: fig-Fig_4
#| fig-format: svg
#| fig-width: 13
#| fig-height: 10
#| echo: false
#| silent: true
#| message: false
#| warning: false
#| fig-cap: "Parameter recovery from 1000 replicate simulations and refits of the full model using five‑fold spatial cross‑validation. Blue half‑violin/half‑box plots show the distribution of estimation errors (posterior mean of the fitted parameter minus its true value). a) Process‑level parameters: errors grouped by ecological process (competition, growth, mortality, regeneration) and shown for the corresponding process parameters (e.g., compHeight, growthLight, mortSize). b) Environmental parameter estimates: errors for the weights associated with the intercept and six climatic covariates (Prec, SR_kW_m2, RH_prc, T_max, T_min, swp) within each process. Because the neural‑network component consists of a single linear layer, these weights are equivalent to classical multivariate linear‑regression coefficients. The red horizontal line indicates perfect recovery (error = 0)."

models = list.files("results/03_full100reps/", full.names = T, recursive = T)
m_true = torch::torch_load("results/01_full/pft-period7-25patches_full.pt")
m_list = sapply(models, torch::torch_load)
m_pars = lapply(m_list, function(x) x$parameters_r)

i = names(m_true$parameters_r)[1]
m_true$nn_growth$parameters

diffs_df = data.frame()
par_names = c("par_competition_r", "par_growth_r", "par_mortality_r", "par_regeneration_r")
for(i in par_names){
  for(c in 1:ncol(m_true[[i]])){
    for(m in m_list[1:length(m_list)]){
      diffs_df = rbind(
        diffs_df,
        data.frame(diff = m_true[[i]][,c] - m[[i]][,c], par = paste0(i,c))
        )
    }
  }
}

par_names_nn = c("nn_mortality.0.weight", "nn_growth.0.weight", "nn_regeneration.0.weight")
for(i in par_names_nn){
  for(c in 1:ncol(m_true$parameters_r[[i]])){
    for(m in m_list[1:length(m_list)]){
      diffs_df = rbind(
        diffs_df,
        data.frame(diff = m_true$parameters_r[[i]][,c] - m$parameters_r[[i]][,c], par = paste0(i,c))
      )
    }
  }
}

log_mod <- function(x, base = exp(1)) {
  # Vorzeichenmatrix (0 bekommt hier schon das richtige Vorzeichen = 0)
  sgn <- sign(x)
  # Logarithmus von (|x| + 1); bei x = 0 ergibt das log(1) = 0
  log_part <- log(abs(x) + 1, base = base)
  # Kombination von Vorzeichen und Betrag
  result <- sgn * log_part
  # Nur zur Sicherheit: stellt sicher, dass exakt x == 0 auch exakt 0 ergibt
  result[x == 0] <- 0
  return(result)
}
log_mod(-10:10)
par(mfrow = c(1,1), mar = c(3,8,1,1))
boxplot(log_mod(diff) ~ par, data = diffs_df, horizontal = T, las = 1, cex.axis = 0.7)
abline(v = 0)


# create transformation for log modulu
library(scales) 
# -----------------------------------------------------------
# 1)  Transformation definieren
# -----------------------------------------------------------
log_mod_trans <- function(base = exp(1)) {
  trans_new(
    name      = paste0("log_mod-", format(base)),
    transform = function(x) sign(x) * log(abs(x) + 1, base = base),
    inverse   = function(y) sign(y) * (base^abs(y) - 1),
    breaks    = pretty_breaks(),      # Tick‑Positionen auf Originalskala
    domain    = c(-Inf, Inf)
  )
}

# -----------------------------------------------------------
# 2)  Beispielplot mit log_mod‐Skala, Original‑Labels
# -----------------------------------------------------------
ggplot(diffs_df, aes(y = par, x = diff)) +
  geom_boxplot() +
  labs(y = "Parameter", x = "Difference") +
  scale_x_continuous(
    trans  = log_mod_trans(),           # ← hier anwenden
    breaks = pretty_breaks(n = 7)       # (optional) schönere Tick‑Abstände
  ) +
  theme_minimal()

library(ggplot2)
library(ggbeeswarm)
library(gghalves)
library(data.table)
names(diffs_df)
diffs_dt <- data.table(diffs_df)
unique(diffs_df$par)
diffs_dt[grepl("competition",par),process := "competition",]
diffs_dt[grepl("competition_r1",par),name := "compHeight",]
diffs_dt[grepl("competition_r2",par),name := "compStr",]
diffs_dt[grepl("growth",par),process := "growth",]
# diffs_dt[grepl("nn_growth.0.weight1",par),process := "growth",]
# diffs_dt[grepl("nn_growth.0.weight1",par),name := "intercept",]
diffs_dt[grepl("growth_r1",par),name := "growthLight",]
diffs_dt[grepl("growth_r2",par),name := "growthSize",]
diffs_dt[grepl("mortality",par),process := "mortality",]
# diffs_dt[grepl("nn_mortality.0.weight1",par),process := "mortality",]
# diffs_dt[grepl("nn_mortality.0.weight1",par),name := "intercept",]
diffs_dt[grepl("mortality_r1",par),name := "mortLight",]
diffs_dt[grepl("mortality_r2",par),name := "mortSize",]
diffs_dt[grepl("mortality_r3",par),name := "mortGrowth",]
diffs_dt[grepl("regeneration",par),process := "regeneration",]
diffs_dt[grepl("regeneration_r1",par),name := "regLight",]
# diffs_dt[grepl("nn_regeneration.0.weight1",par),process := "regeneration",]
# diffs_dt[grepl("nn_regeneration.0.weight1",par),name := "intercept",]
# diffs_dt[grepl("par",par) | grepl("weight1", par),type := "process parameter",]
# diffs_dt[grepl("nn_",par) & !grepl("weight1", par),type := "environment parameter",]
diffs_dt[grepl("par",par),type := "process parameter",]
diffs_dt[grepl("nn_",par),type := "environment parameter",]

diffs_dt[type == "environment parameter",name := gsub("weight","",tstrsplit(par, ".", fixed = T)[[3]]),]

# make "intercept" allways the first
diffs_dt[,name := factor(name, levels = c("intercept", unique(diffs_dt[name != "intercept"]$name))),]

p_proc <- ggplot(diffs_dt[type == "process parameter"], aes(x = name, y = diff)) +
  # see::geom_violinhalf(scale = "width", flip = T)+
  geom_hline(yintercept = 0, color = "red") +
  geom_half_violin(scale = "width", fill = "blue")+
  geom_half_boxplot(side = "r", outlier.shape = NA)+
  facet_wrap(~process, ncol = 2, scales = "free") +
  labs(x = "Parameter", y = "Difference")+
  theme_classic()

fac_levels = c("intercept","Prec","SR_kW_m2","RH_prc","T_max","T_min","swp")

p_env <- ggplot(diffs_dt[type == "environment parameter"], 
       aes(x = factor(name, levels = 1:7, labels = fac_levels), y = diff)
       ) +
  # see::geom_violinhalf(scale = "width", flip = T)+
  geom_hline(yintercept = 0, color = "red") +
  geom_half_violin(scale = "width", fill = "blue")+
  geom_half_boxplot(side = "r", outlier.shape = NA)+
  facet_wrap(~process, ncol = 1, scales = "free") +
  labs(x = "Parameter", y = "Difference")+
  theme_classic()


gridExtra::grid.arrange(
  grobs = list(
    label_grob_f("a"), label_grob_f("b"),
    p_proc, p_env
  ), 
  layout_matrix = rbind(
    c(1,2),
    c(3,4)
  ),
  # include letters to each plot
  widths = c(0.6,0.6), 
  heights = c(0.05,0.95)
)

```





