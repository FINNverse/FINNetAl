---
title: ""
format: 
  docx:
    keep-md: false
    fig-format: pdf
crossref:
  fig-title: '**Figure**'
  fig-labels: arabic
  tbl-title: '**Table**'
  tbl-labels: arabic
  title-delim: ":"
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(dev = "cairo_pdf")
knitr::opts_chunk$set(fig.path="figures/", echo = FALSE)
```


```{r}
#| echo: false
#| message: false
library(ggplot2)
library(data.table)
source("code/plot-functions.R")
library(gridExtra)
library(grid)
library(FINN)
library(ggbeeswarm)
library(gghalves)
library(data.table)
library(tidyverse)


pft_cols <- c(
  Slow                         = "#BF7DA5",  # pink-mauve
  Fast                         = "#DBA242",  # ochre-orange
  `Long-lived pioneer (LLP)`   = "#479C77",  # medium green
  `Short-lived breeder (SLB)`  = "#3471AE",  # mid blue
  Intermediate                 = "#C36837"   # terracotta
)
pft_cols_int <- pft_cols
names(pft_cols_int) <- 1:5

# Function to extract the legend as a grob
get_legend <- function(ggplot_obj) {
  # Build the gtable
  plot_gtable <- ggplot_gtable(ggplot_build(ggplot_obj+guides(colour = guide_legend(nrow = 1))))
  
  # Find the index of the guide box (the legend)
  guide_index <- which(sapply(plot_gtable$grobs, function(x) x$name) == "guide-box")
  
  # Return the legend grob
  if (length(guide_index) > 0) {
    return(plot_gtable$grobs[[guide_index]])
  } else {
    warning("No legend found.")
    return(NULL)
  }
}

label_grob_f = function(x){
  textGrob(x, x = unit(0.05, "npc"), y = unit(0.95, "npc"), just = c("left", "top"), gp = gpar(fontsize = 16, fontface = "bold"))
}


#' Draw a GAM smooth (±SE) without plotting points
#'
#' @param x,y        numeric vectors (explanatory, response) of equal length.
#' @param n          grid size for predictions (controls curve resolution).
#' @param se.mult    SE multiplier (≈2 for 95 % band).
#' @param add        logical; overlay on current plot (`TRUE`) or start a new
#'                   blank frame (`FALSE`, default).
#' @param formula    GAM formula (default = y ~ s(x, bs = "cs")).
#' @param family     glm family; if NULL and all(y > 0) defaults to
#'                   `Gamma(link = "log")`, otherwise `gaussian()`.
#' @param gam_args   named list of extra arguments for `mgcv::gam()` (optional).
#' @param col,lwd    colour / line-width for the central smooth.
#' @param se.col,se.lty  colour / lty for the ±SE curves.
#' @param ...        further arguments passed **only** to `plot()` when
#'                   `add = FALSE` (axis labels, limits, …).
#'
#' @return invisibly a data.frame of x, fit, upr, lwr.
#'
#' @examples
#' set.seed(1)
#' x <- runif(120, 0, 10)
#' y <- exp(0.5 * sin(x)) + rlnorm(120, 0, 0.1)
#'
#' ## (1) default smooth chosen for positive data
#' lines_gam(x, y)
#'
#' ## (2) a *smoother* curve with REML + higher gamma
#' plot(x, y, pch = 19, col = "#00000044")
#' lines_gam(
#'   x, y,
#'   add       = TRUE,
#'   formula   = y ~ s(x, k = 30),     # more basis functions
#'   gam_args  = list(method = "REML", gamma = 1.6),
#'   col       = "tomato"
#' )
lines_gam <- function(x, y,
                      n        = 100,
                      se.mult  = 2,
                      add      = FALSE,
                      formula  = NULL,
                      family   = NULL,
                      gam_args = list(),
                      col      = "#6c9fca",
                      lwd      = 3,
                      se.col   = col,
                      se.lty   = 2,
                      se = F,
                      ...) {
  
  ## --------- sanity checks & setup -----------------------------------------
  stopifnot(length(x) == length(y))
  if (!requireNamespace("mgcv", quietly = TRUE))
    stop("Package 'mgcv' is required; install it with install.packages('mgcv').")
  
  dat <- data.frame(x = x, y = y)
  
  ## choose family if none supplied
  if (is.null(family))
    family <- if (all(y > 0)) Gamma(link = "log") else gaussian()
  
  ## default formula if none supplied
  if (is.null(formula))
    formula <- y ~ s(x, bs = "cs")
  
  ## --------- fit model (extra args allowed) ---------------------------------
  gam_call <- c(
    list(formula = formula, data = dat, family = family),
    gam_args
  )
  mod <- do.call(mgcv::gam, gam_call)
  
  ## --------- predictions on link scale -------------------------------------
  xs  <- seq(min(x, na.rm = TRUE), max(x, na.rm = TRUE), length.out = n)
  pr  <- predict(mod, newdata = data.frame(x = xs), se.fit = TRUE)
  
  fit.lin <- pr$fit
  se.lin  <- pr$se.fit
  
  ## back-transform to response scale
  linkinv <- family$linkinv
  fit <- linkinv(fit.lin)
  upr <- linkinv(fit.lin + se.mult * se.lin)
  lwr <- linkinv(fit.lin - se.mult * se.lin)
  
  ## --------- draw -----------------------------------------------------------
  if (!add) {
    plot(x, y, type = "n", ...)       # blank plotting region
  } else if (is.null(dev.list())) {
    stop("No active graphics device – call plot() first or set add = FALSE.")
  }
  
  lines(xs, fit, col = col,      lwd = lwd)
  if(se == T){
    lines(xs, upr, col = se.col,   lty = se.lty)
    lines(xs, lwr, col = se.col,   lty = se.lty)
  }
  
  invisible(data.frame(x = xs, fit = fit, upr = upr, lwr = lwr))
}
```



```{r}
#| echo: false
#| message: false

# Read fitted models

chosen_scale = "pft-period7-25patches"
fitted_models <- c(
    list.files("results/02_realdata/", full.names = T, recursive = T, pattern = chosen_scale),
    list.files("results/02_realdata_hybridTF0/", full.names = T, recursive = T, pattern = chosen_scale)
    # list.files("results/02_realdata_hybridSmall/", full.names = T, recursive = T, pattern = chosen_scale)
)
fitted_models <- fitted_models[grepl("S0_T0",fitted_models)]

```



### Figure 2 - Recovery of functional form

```{r}
#| label: fig-figure_2
#| fig-format: pdf
#| fig-width: 12
#| fig-height: 6
#| echo: false
#| silent: true
#| message: false
#| warning: false
#| fig-cap: "Hybrid-FINN recovers the functional form of a process and improves predictive performance. To test whether Hybrid-FINN can recover the functional form of a process, we simulated data from a Process-FINN model (M1), in which the functional form of the growth process includes an environmental unimodal niche curve (quadratic effect of the environment). Then, we tested two models: M3, a Hybrid-FINN in which growth was replaced by a deep neural network; and M2, a misspecified Process-FINN model with an assumed linear relationship between environment and growth. (a) compares  the calibrated growth-environment relationships of models M2 and M3 to the true model M1. (b) compares the predictive performance of models M2 and M3 with the observed data, measured by the Spearman correlation factor. Correlations are based on equilibrium simulations and represent the relation for each variable and site over 500 simulated timesteps."

load("results/functional_form.RData")
formula = y ~ s(x,bs="cr",  k= 5)

par(mfrow = c(1, 2))

plot(pred_m1env_dt$env1, (pred_m1env_dt$growth*pred_m1env_dt$dbh), col = NA, ylab = "dbh growth", xlab = "environment", ylim = c(0, 5), las = 1)
mtext("a", side = 3, line = 0.1, adj = -0.3, font = 2, xpd = NA)  # 'a' at top-left
lines_gam(pred_m1env_dt$env1, (pred_m1env_dt$growth*pred_m1env_dt$dbh), col = "black", add = T, formula = formula, ylim = c(0,3))
lines_gam(pred_m2env_dt$env1, (pred_m2env_dt$growth*pred_m2env_dt$dbh), col = "#fe944e", add = T, formula = formula, ylim = c(0,3))
lines_gam(pred_m3env_dt$env1, (pred_m3env_dt$growth*pred_m3env_dt$dbh), col = "#6c9fca", add = T, formula = formula, ylim = c(0,3))
legend("topleft", legend = c("M1 (true form)", "M2 (wrong form)", "M3 (hybrid model)"), col = c("black", "#fe944e", "#6c9fca"), lty = 1, bty = "n", lwd = 3)
text(-2.5, 5.40, xpd = NA, labels = "a", font = 2, cex = 1.4 )


boxplot(r~model+variable2, data=cor_dt_form, xaxt = "n", las = 1, at = c(0, 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16), col = c("#fe944e", "#6c9fca"), xlab = "")
axis(1, at= c(0.5, 3.5, 6.5, 9.5, 12.5, 15.5), labels = rep("", 6))
text(x = c(0.5, 3.5, 6.5, 9.5, 12.5, 15.5), levels(cor_dt_form$variable2), y = -0.42, xpd = NA)
legend("bottomleft", bty = "n", legend = c("M2 (wrong from)", "M3 (hybrid model)"), col = c("#fe944e", "#6c9fca"), pch = 15)
text(-2.5, 1.11, xpd = NA, labels = "b", font = 2, cex = 1.4 )

```


### Figure 3 - Spearman correlation between predicted and observed

```{r}
#| echo: false
#| silent: true
#| message: false
#| warning: false

chosen_scale = "pft-period7-25patches"

fitted_models_fig4 <- fitted_models

## create fit simulations
fit_process = build_model_dt(pt_file = fitted_models_fig4[1])[[1]]

for(i_hybrid_model in fitted_models_fig4[grepl("hybrid",fitted_models_fig4)]){
  
  fit_hybrid = build_model_dt(pt_file = i_hybrid_model)[[1]]
  all_dt = rbind(
    data.table(fit_process[test_train == "train"], type = "process"),
    data.table(fit_hybrid[test_train == "train"], type = "hybrid")
  )
  period_length = unique(all_dt[!is.na(period_length)]$period_length)
  all_dt <- all_dt[,-c("period_length")]
  
  all_dt2 <- melt(all_dt, id.vars = c("type","siteID","year","species","test_train"))
  all_dt2[grepl("pred",variable), pred_obs := "pred",]
  all_dt2[grepl("obs",variable), pred_obs := "obs",]
  all_dt2[, variable := gsub(".obs|.pred","",variable),]
  
  p_dat <- all_dt2[test_train == "train",.(value = mean(value,na.rm = T)), by = .(type,year,species,test_train, pred_obs, variable)]
  p_dat2 <- p_dat[!is.na(value)]
  
  p_dat2_all <- 
    rbind(
      p_dat2[variable %in% c("ba", "trees"),.(
        value = sum(value, na.rm = T),
        species = "all"
      ), by = .(type, year, test_train, pred_obs, variable)],
      p_dat2[variable %in% c("dbh", "reg","growth","mort"),.(
        value = mean(value, na.rm = T),
        species = "all"
      ), by = .(type, year, test_train, pred_obs, variable)]
    )
  
  p_dat2 <- rbind(
    p_dat2,
    p_dat2_all
  )
  
  p_dat2[variable %in% c("ba", "trees"), value := value/0.1,]
  p_dat2[variable %in% c("mortality", "growth"), value := value/5*100,]
  
  cors_fullPlot = fread("results/cors_fullPlot.csv")
  cors_fullPlotSpecies <- fread("results/cors_fullPlotSpecies.csv")
  
  all_cors <- rbind(
    data.table(cors_fullPlot, species = "all"),
    cors_fullPlotSpecies
  )
  p_dat2[,species2 := factor(species, levels = 1:5, labels = names(pft_cols)),]
  
  all_cors <- all_cors[scale == chosen_scale & grepl("T0", cv),]
  all_cors[data == strsplit(i_hybrid_model,"/")[[1]][2],type := "hybrid",]
  all_cors[data == "02_realdata",type := "process",]
  all_cors[, type := factor(type, levels = c("process", "hybrid"), ordered = T),]
  all_cors <- all_cors[!is.na(type)]
  all_cors[,species := factor(species, levels = c(sort(unique(all_cors$species)))),]
  all_cors[,species2 := factor(species, levels = 1:5, labels = names(pft_cols)),]
  
  vars = c("ba", "trees", "dbh", "reg","growth","mort")
  var_labels <- c(
    expression(basal~area~(m^2~ha^-1)),
    expression(trees~(ha^-1)),
    expression(dbh~(cm)),
    expression(regeneration~(ha^-1)),
    expression(growth~(m^3~ha^-1~yr^-1)),
    expression(mortality~(m^3~ha^-1~yr^-1))
  )
  var_labels2 <- c(
    "basal~area~(m^2~ha^-1)",
    "trees~(ha^-1)",
    "dbh~(cm)",
    "regeneration~(ha^-5)",
    "growth~('%'~yr^-1)",
    "mortality~('%'~yr^-1)"
  )
  p_dat2[,variable2 := factor(
    variable, 
    levels = vars,
    labels = var_labels2),]
  
  
  p_dat2[, pred_obs2 := factor(pred_obs, levels = c("obs","pred"), labels = c("observation","prediction")) ,]
  
  if(grepl("period35",chosen_scale)){
    p_dat2[, year2 := 1984+year,]
  }else{
    p_dat2[, year2 := 1985+year*5,]
  }
  
  p_dat2cast <- dcast(p_dat2, type + year2 + variable2 + species ~ pred_obs2, value.var = "value")
  p_dat2cast[,species2 := factor(species, levels = 1:5, labels = names(pft_cols)),]
  p_dat2[,type2 := type,]
  p_dat2[pred_obs == "obs",type2 := "observation",]
  p_dat2[,type2 := factor(type2, levels = c("observation", "process", "hybrid"), 
                          labels = c("Observed", "Predicted (Process Model)", "Predicted (Hybrid Model)")),]
  p_dat2[is.na(species2), species2 := "all",]
  
  p_list <- list()
  for(j_type in c("process","hybrid")){
    i_pdat = p_dat2[type == j_type,]
    j_linetype = ifelse(j_type == "process", "dashed", "dotted")
    j_pointtype = ifelse(j_type == "process", 1, 2)
   }
  p_dat2cast[is.na(species2),species2 := "all",]
  all_cors[,type2 := factor(type, levels = c("process", "hybrid"), labels = c("Process", "Hybrid")),]
  all_cors[,variable:= factor(variable, levels = c("ba","trees","dbh","reg", "growth", "mort"),ordered = T)]
  all_cors[is.na(species2),species2 := "all",]

}


```

```{r}
#| label: fig-figure_3
#| fig-format: pdf
#| fig-width: 7
#| fig-height: 5
#| echo: false
#| silent: true
#| message: false
#| warning: false
#| fig-cap: "Spearman correlation of observed and simulated variables for five PFTs from the five-fold blocked spatial cross-validation of all models calibrated/trained on the BCI data. 'Process' refers to Process-FINN as a full process model with fixed functional forms, 'Hybrid' refers to Hybrid-FINN in which the growth process is replaced by a DNN, 'Naïve NN' refers to a single DNN that was trained on the response variables for each time step. The naïve NN received the derived response variables of each previous time step as well as the current environment as input. PFTs are according to Rüger et al. (2020)"

cors_naive = fread("results/cors_naive.csv")

all_cors
names(cors_naive)[names(cors_naive) == "r"] <- "spearmans_r"
names(cors_naive)[names(cors_naive) == "var"] <- "variable"
cors_naive$type2 = "Naive DNN"
var_labels3 = c("Basal Area [m²/ha]",
                "Trees [N/ha]",
                "DBH [cm]",
                "Regeneration [N/ha]",
                "Growth [%/100]",
                "Mortality [%/100]")
cors_naive[,variable2 := factor(
    variable, 
    levels = vars,
    labels = var_labels3),]
cors_naive[,species2 := factor(species, levels = 1:5, labels = names(pft_cols)),]
cors_naive[is.na(species2), species2 := "all",]

all_cors2 <- rbind(all_cors, cors_naive, fill = T)

var_labels3 = c("Basal Area [m²/ha]",
                "Trees [N/ha]",
                "DBH [cm]",
                "Regeneration [N/ha]",
                "Growth [%/100]",
                "Mortality [%/100]")
all_cors2[,variable2 := factor(
    variable, 
    levels = vars,
    labels = var_labels3),]

p2_full = 
  ggplot(all_cors2, aes(x = type2, y = spearmans_r, color = species2))+
    geom_hline(yintercept = c(-1,0,1), linetype = "solid", color = "grey50", linewidth = 1)+
    geom_boxplot(position = position_dodge())+
    labs(x = "", y = "Spearmans Correlation")+
    theme_classic()+
    facet_wrap(~variable2, ncol = 3)+
    coord_cartesian(ylim = c(-1,1))+
    # fully remove stip
    theme(
          legend.position = "bottom")+
    #move y axis from left side to right side
    scale_y_continuous(position = "left", breaks = c(-1,0,1))+
    scale_color_manual(name = "PFT", values = c(pft_cols, all = "black")) + guides(colour = guide_legend(nrow = 1))
p2_full
```



### Figure 4 - Succession trajectories

```{r}
#| label: fig-figure_4
#| fig-format: pdf
#| fig-width: 10
#| fig-height: 6
#| echo: false
#| silent: true
#| message: false
#| warning: false
#| fig-cap: "Simulated successional trajectories of stand characteristics and demographic rates of five PFTs for Process-FINN (a) and Hybrid-FINN (b), where the growth process is replaced by a DNN. Note that rates are not annual and represent changes of five year intervals. Both models were trained with the BCI forest data with 7 censuses. Forest dynamics were simulated for 600 years. Disturbance regime of Rüger et al. (2020) was used."

obs_dt <- fread("data/BCI/noSplits/pft-period7-25patches/obs_dt.csv")

obs_dt[,species2 := factor(species,levels = 1:5, labels = names(pft_cols)),]

avg_obs_dt <- obs_dt[,.(
  ba = mean(ba)/0.1,
  trees = mean(trees)/0.1,
  dbh = mean(dbh, na.rm = T),
  growth = mean(growth, na.rm = T),
  mort = mean(mort, na.rm = T),
  r_mean_ha = mean(reg, na.rm = T)
), by = species2]
avg_obs_dt2 <- melt(avg_obs_dt, id.vars = "species2", variable.name = "variable", value.name = "value")

## Simulate equilibrium from fitted models
# load fitted BCI models
hybrid_m = torch::torch_load(fitted_models[grepl("hybrid",fitted_models)])
process_m = torch::torch_load(fitted_models[!grepl("hybrid",fitted_models)])

i_name = "pft-period7-25patches"
# # read full raw data
# obs_dt2 = fread(paste0("data/BCI/noSplits/", i_name,"/obs_dt.csv"))
# obs_dt = fread(paste0("data/BCIsecf/stand_dt_secf.csv"))
# cohorts_dt2 = fread(paste0("data/BCI/noSplits/", i_name,"/initial_cohorts1985.csv"))
# cohorts_dt = fread(paste0("data/BCIsecf/initial_cohorts_10patches_0.1ha_age40.csv"))
# cohorts_dt$dbh = cohorts_dt$dbh_cm
env_dt = fread(paste0("data/BCI/noSplits/", i_name,"/env_dt.csv"))
# obs_dt = fread(paste0("data/BCI/noSplits/", i_name,"/obs_dt.csv"))

# predict for model
# cohort1 <- FINN::CohortMat(obs_df = cohorts_dt, sp = uniqueN(obs_dt$species))

# create artificial time series
env_dt_long <- data.table()
start_t = 0
for(k in 1:40){
  env_dt_temp = copy(env_dt)
  # randomly shuffle years in env_dt
  env_dt_temp$year = env_dt_temp$year+start_t
  env_dt_temp[,year := year[sample(length(year))], by = siteID]
  # env_dt_temp$year = env_dt_temp$year[sample(length(env_dt_temp$year), replace = F)]
  env_dt_long = rbind(env_dt_long, env_dt_temp)
  start_t = max(env_dt_long$year)
  # if(start_t > ceiling(80/uniqueN(env_dt$year))) break
}
# env_dt_long$swp = 0
# env_dt_long[,":="(
#   Prec = mean(Prec),
#   SR_kW_m2 = mean(SR_kW_m2),
#   RH_prc = mean(RH_prc),
#   T_max = mean(T_max),
#   T_min = mean(T_min)
# ), by = siteID]
# here we specify a disturbance frequency of 1%, which means that there is a 1% chance each year that a disturbance occurs
disturbance_frequency = 1

Ntimesteps = uniqueN(env_dt_long$year)
Ntimesteps = max(env_dt_long$year)
Nsites = uniqueN(env_dt_long$siteID)
# the disturbance intensity at each timestep is the fraction of patches that is disturbed at that time step
# here we specify a disturbance frequency of 1%, which means that there is a 1% chance each year that a disturbance occurs
disturbance_intensity = runif(Ntimesteps*Nsites, 0.0043, 0.016)
#length(disturbance_intensity)
dist_dt <- env_dt_long[,.(siteID, year)]
# this will result in 0 to 20 % of the patches being disturbed at each timestep with a change of 1% that a disturbance occurs at the timestep
dist_dt$intensity = rbinom(Ntimesteps*Nsites, 1, disturbance_frequency)*disturbance_intensity

pred_hybrid = hybrid_m$simulate(env = env_dt_long, disturbance = dist_dt, init_cohort = NULL, patches = 20, patch_size = 0.1)

pred_process = process_m$simulate(env = env_dt_long, disturbance = dist_dt, init_cohort = NULL, patches = 20, patch_size = 0.1)

patch_size = 0.1
predictions = list()
predictions[["pred_hybrid"]] = pred_hybrid
predictions[["pred_process"]] = pred_process
p_list = list()
for(i in c("pred_hybrid","pred_process")){
  p_dat <- predictions[[i]]$long$site[, .(value = mean(value)), by = .(year = 1+(year-1)*5, species, variable)]
  p_dat$model = i
  p_dat[,species2 := factor(species, levels = 1:5, labels = names(pft_cols)),]
  p_dat[, variable2 := factor(
  variable,
  levels = c("ba", "trees", "dbh", "AL", "growth", "mort", "r_mean_ha"),
  labels =  c("Basal Area [m²/ha]", "Trees [N/ha]", "avg. DBH [cm]",
              "Available Light [%]", "Growth [%/100]", "Mortality [%/100]", 
              "Reg. Mean [N/ha]")
  ),]
  avg_obs_dt2[, variable2 := factor(
  variable,
  levels = c("ba", "trees", "dbh",  "AL", "growth", "mort", "r_mean_ha"),
  labels =  c("Basal Area [m²/ha]", "Trees [N/ha]", "avg. DBH [cm]",
              "Available Light [%]", "Growth [%/100]", "Mortality [%/100]", 
              "Reg. Mean [N/ha]")
  ),]
  p_dat <- p_dat[!is.na(variable2)]
  p_dat[variable %in% c("ba", "trees"), value := value/patch_size,]
  
  p_dat_dummy = data.table::copy(p_dat)
  p_dat_dummy[variable == "dbh"][1:2]$value = c(0, 18)
  p_dat_dummy[variable == "ba"][1:2]$value = c(0, 40)
  p_dat_dummy[variable == "trees"][1:2]$value = c(0, 3000)
  p_dat_dummy[variable == "growth"][1:2]$value = c(0, 1.2)
  p_dat_dummy[variable == "mort"][1:2]$value = c(0, 0.5)
  p_dat_dummy[variable == "r_mean_ha"][1:2]$value = c(0, 310)
  
  p <- ggplot(p_dat, aes(x = year, y = value, color = species2)) +
    geom_line(linewidth = 1) +
    labs(x = "Year", y = "Value") +
    coord_cartesian(ylim = c(0, NA)) +
    facet_wrap(~variable2, scales = "free_y", ncol = 2, strip.position = "left") +  # Remove label_parsed
     geom_blank(data=p_dat_dummy) + 
    theme_classic() +
    # ylab("Basal Area [m²/ha]") +
    scale_color_manual(
      name = "PFT", values = pft_cols)+
    theme(
    axis.title.y = element_blank(),
    strip.placement = "outside",
    strip.text.y.left = element_text(angle = 90),
    strip.background = element_blank(),
    legend.position = "bottom",
    legend.key.size = unit(0.001, "mm"),
    legend.key.width = unit(2, "line")
    # legend.position.inside = c(0.9,0.2),
    # legend.background = element_rect(color = "black", fill = NA)
  )+
    guides(color = guide_legend(ncol = 1,byrow = TRUE))
    # ggtitle(paste0("patches = ",gsub("patches_", "", i)))
  legend_p <- get_legend(p)
  
  p_list[[i]] <- p#+theme(legend.position = "none")
}

grid.arrange(
  grobs = c(
    list(label_grob_f("a"), label_grob_f("b")),
    list(p_list[[2]]+theme(legend.position = "none"), 
         p_list[[1]]+theme(legend.position = "none")), list(legend_p)),
  ncol = 2,
  layout_matrix = rbind(c(1, 2), c(3, 4), c(5,5)),
  heights = c(0.05, 0.90,0.2)
)
#print(p_list[[1]]+geom_hline(data = avg_obs_dt2,aes(yintercept = value, color = species2), linetype = "dashed", linewidth = 0.5))
#print(p_list[[2]]+geom_hline(data = avg_obs_dt2,aes(yintercept = value, color = species2), linetype = "dashed", linewidth = 0.5))



```



<!-- #### boxplots of cv corr -->

<!-- ```{r} -->
<!-- #| label: fig-Fig_cv-cor-only -->
<!-- #| fig-format: pdf -->
<!-- #| fig-width: 7 -->
<!-- #| fig-height: 5 -->
<!-- #| echo: false -->
<!-- #| silent: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-cap: "Calculated pearson correlation from the five-fold blocked spatial cross-validation. The first two rows show the observed and predicted values for basal area and tree density. The third and fourth row show the observed and predicted values for diameter at breast height (dbh), regeneration, growth, and mortality." -->

<!-- var_labels3 = c("Basal Area [m²/ha]", -->
<!--                 "Trees [N/ha]", -->
<!--                 "DBH [cm]", -->
<!--                 "Regeneration [N/ha]", -->
<!--                 "Growth [%/100]", -->
<!--                 "Mortality [%/100]") -->
<!-- all_cors[,variable2 := factor( -->
<!--     variable,  -->
<!--     levels = vars, -->
<!--     labels = var_labels3),] -->

<!-- p2_full =  -->
<!--   ggplot(all_cors, aes(x = type2, y = spearmans_r, color = species2))+ -->
<!--     geom_hline(yintercept = c(-1,0,1), linetype = "solid", color = "grey50", linewidth = 1)+ -->
<!--     geom_boxplot(position = position_dodge())+ -->
<!--     labs(x = "", y = "Spearmans Correlation")+ -->
<!--     theme_classic()+ -->
<!--     facet_wrap(~variable2, ncol = 3)+ -->
<!--     coord_cartesian(ylim = c(-1,1))+ -->
<!--     # fully remove stip -->
<!--     theme( -->
<!--           legend.position = "bottom")+ -->
<!--     #move y axis from left side to right side -->
<!--     scale_y_continuous(position = "left", breaks = c(-1,0,1))+ -->
<!--     scale_color_manual(name = "PFT", values = c(pft_cols, all = "black")) -->
<!-- p2_full -->
<!-- ``` -->


### Figure 5 - Explainable AI

```{r}
#| label: fig-figure_5
#| fig-format: pdf
#| fig-width: 13
#| fig-height: 10
#| echo: false
#| silent: true
#| message: false
#| warning: false
#| fig-cap: "Simulated relative growth response to available light and tree size (dbh) for 5 PFTs for the hybrid model (a) and the process model (b). Visualizations are based on accumulated local effect plots. Uncertainties for Hybrid-FINN (A) are based on Monte-Carlo Dropout. Swp is the observed soil water potential."

load("results/03_xAI/results_xAI.RData")

pft_cols <- c(
  Slow                         = "#BF7DA5",  # pink-mauve
  Fast                         = "#DBA242",  # ochre-orange
  `Long-lived pioneer (LLP)`   = "#479C77",  # medium green
  `Short-lived breeder (SLB)`  = "#3471AE",  # mid blue
  Intermediate                 = "#C36837"   # terracotta
)

addA = function(col, alpha = 0.25) apply(sapply(col, grDevices::col2rgb)/255, 2, function(x) grDevices::rgb(x[1], x[2], x[3], alpha=alpha))


tmp = data.frame(df_results_ale) |> group_by(features, species, x) |> summarize(features = unique(features), x = mean(x), y = mean(y), species = unique(species)) |> as.data.table()
tmp_sd = data.frame(df_results_ale) |> group_by(features, species, x) |> summarize(features = unique(features), x = mean(x), y = sd(y), species = unique(species)) |> as.data.table()


par(mfrow = c(2, 3), mar = c(1.5, 2.0, 0, 1.0), oma = c(5, 5, 2, 2))
plot(NULL, NULL, ylim = c(0, 0.82), xlim = c(0, 130), las = 1, xlab = "", ylab="growth", xaxt = "n", axes=F)
text(-30, y = 0.8, pos = 3, xpd = NA, cex = 1.5, font = 2, label = "A")
text(srt = 90, label = "growth", x = -30, y = 0.36, pos = 3, xpd = NA)

for(i in 1:5) polygon(x = c(tmp[features=="dbh"][species==i]$x, rev(tmp[features=="dbh"][species==i]$x)),
                      y = c(tmp[features=="dbh"][species==i]$y - 1.96*tmp_sd[features=="dbh"][species==i]$y, rev(tmp[features=="dbh"][species==i]$y + 1.96*tmp_sd[features=="dbh"][species==i]$y)), 
                      lwd = 1.6, 
                      col =  addA(pft_cols[i], alpha = 0.4), border = NA)

for(i in 1:5) points(tmp[features=="dbh"][species==i][,3:4], type = "l", lwd = 1.6, 
                     col =  pft_cols[i])
axis(2, las = 1)

plot(NULL, NULL, ylim = c(0, 0.82), xlim = c(0, 1), las = 1, xlab = "", ylab="", yaxt = "n", xaxt = "n", axes = F)
for(i in 1:5) polygon(x = c(tmp[features=="light"][species==i]$x, rev(tmp[features=="light"][species==i]$x)),
                      y = c(tmp[features=="light"][species==i]$y - 1.96*tmp_sd[features=="light"][species==i]$y, 
                            rev(tmp[features=="light"][species==i]$y + 1.96*tmp_sd[features=="light"][species==i]$y)), 
                      lwd = 1.6, 
                      col =  addA(pft_cols[i], alpha = 0.4), border = NA)
for(i in 1:5) points(as.data.table(tmp)[features=="light"][species==i][,3:4], type = "l", lwd = 1.6, 
                     col =  pft_cols[i])
axis(2, las = 1)

plot(NULL, NULL, ylim = c(0, 0.82), xlim = c(-1.8, 1.8), las = 1, xlab = "", ylab="", yaxt = "n", xaxt = "n", axes = F)
for(i in 1:5) polygon(x = c(tmp[features=="swp"][species==i]$x, rev(tmp[features=="swp"][species==i]$x)),
                      y = c(tmp[features=="swp"][species==i]$y - 1.96*tmp_sd[features=="swp"][species==i]$y, 
                            rev(tmp[features=="swp"][species==i]$y + 1.96*tmp_sd[features=="swp"][species==i]$y)), 
                      lwd = 1.6, 
                      col =  addA(pft_cols[i], alpha = 0.4), border = NA)
for(i in 1:5) points(as.data.table(tmp)[features=="swp"][species==i][,3:4], type = "l", lwd = 1.6, 
                     col =  pft_cols[i])
axis(2, las = 1)

plot(NULL, NULL, ylim = c(0, 0.82), xlim = c(0, 130), las = 1, xlab = "dbh", ylab="growth", axes = F)
text(-30, y = 0.8, pos = 3, xpd = NA, cex = 1.3, font = 2, label = "B")
text(srt = 90, label = "growth", x = -30, y = 0.36, pos = 3, xpd = NA)
for(i in 1:5) points(as.data.table(df_results_ale_process)[features=="dbh"][species==i][,3:4], type = "l", lwd = 1.6, 
                     col =  pft_cols[i])
axis(2, las = 1)
axis(1, las = 1)
text(x = 65, y = -0.2, pos = 1, xpd = NA, label = "dbh")

plot(NULL, NULL, ylim = c(0, 0.82), xlim = c(0, 1), las = 1, xlab = "light", ylab="", yaxt = "n", axes =F)
for(i in 1:5) points(as.data.table(df_results_ale_process)[features=="light"][species==i][,3:4], type = "l", lwd = 1.6, 
                     col =  pft_cols[i])
text(x = 0.5, y = -0.2, pos = 1, xpd = NA, label = "light")
axis(2, las = 1)
axis(1, las = 1)

plot(NULL, NULL, ylim = c(0, 0.82), xlim = c(-1.8, 1.8), las = 1, xlab = "swp", ylab="", yaxt = "n", axes =F)
for(i in 1:5) points(as.data.table(df_results_ale_process)[features=="swp"][species==i][,3:4], type = "l", lwd = 1.6, 
                     col =  pft_cols[i])
text(x = 0.0, y = -0.2, pos = 1, xpd = NA, label = "swp")
legend("topleft", bty = "n", col = pft_cols, lty = 1, lwd = 1.3, legend = names(pft_cols))
axis(2, las = 1)
axis(1, las = 1)


```


<!-- ## Figure 6 (competition) -->

<!-- ```{r} -->
<!-- #| label: fig-Fig_6 -->
<!-- #| fig-format: pdf -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 10 -->
<!-- #| echo: false -->
<!-- #| silent: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-cap: "" -->

<!-- ba_dt =  -->
<!--   data.table( -->
<!--     expand.grid( -->
<!--       list( -->
<!--         trees = 1:1000, -->
<!--         dbh = seq(0, 100,1) -->
<!--       ) -->
<!--     ) -->
<!--   ) -->

<!-- ba_dt$rowID = 1:nrow(ba_dt) -->
<!-- ba_dt[, ba := BA_stand(dbh, trees,1), by = rowID] -->

<!-- p_ba = -->
<!--   ggplot(ba_dt, aes(x = dbh, y = trees, fill = ba)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradientn( -->
<!--     colours = rev(viridis::viridis(100)), -->
<!--     limits = c(0, 100), -->
<!--     na.value = rev(viridis::viridis(100))[100], -->
<!--     breaks = seq(0, 100, 20), -->
<!--     labels = c(seq(0, 80, 20),">100"), -->
<!--     name = "Basal Area\n[m2/ha]" -->
<!--   )+ -->
<!--   xlab("dbh [cm]")+ -->
<!--   ylab("trees [ha]")+ -->
<!--   theme_classic() -->

<!-- height_dt = -->
<!--   data.table( -->
<!--     expand.grid( -->
<!--       list( -->
<!--         dbh = seq(0, 300,1), -->
<!--         parHeight = seq(0,1,0.2) -->
<!--       ) -->
<!--     ) -->
<!--   ) -->

<!-- height_dt$rowID = 1:nrow(height_dt) -->
<!-- height_dt[, height := height(dbh, parHeight), by = rowID] -->

<!-- p_height <- -->
<!--   ggplot(height_dt, aes(x = dbh, y = height, color = factor(parHeight, ordered = T)))+ -->
<!--   ylab("height(dbh,parHeight)")+ -->
<!--   xlab("dbh [cm]")+ -->
<!--   geom_line()+ -->
<!--   theme_classic()+ -->
<!--   scale_color_discrete(name = "parHeight") -->

<!-- ## Competition -->
<!-- parHeight_vec = c(0.7) -->
<!-- parCompStr = c(0.1,0.2,0.3) -->
<!-- parComp = cbind(parHeight_vec, parCompStr) -->

<!-- cohort_layers_dt <- data.table( -->
<!--   name = c("understory", "midstory", "overstory"), -->
<!--   trees = c(1000, 300, 50), -->
<!--   dbh = c(5, 30, 90), -->
<!--   dbh_shape = c(2, 4, 5) -->
<!-- ) -->

<!-- cohort_layers1_dt <- data.table() -->
<!-- for(i_c in 1:nrow(cohort_layers_dt)){ -->
<!--   dbh = cohort_layers_dt$dbh[i_c] -->
<!--   trees = cohort_layers_dt$trees[i_c] -->
<!--   dbh_shape = cohort_layers_dt$dbh_shape[i_c] -->
<!--   temp_cohort_df1 = data.table(FINN::rweibull_cohorts(trees = trees, dbh_shape = dbh_shape, dbh_scale = dbh, dbh_class_range = 0.1, species = 1, siteID = 1)) -->
<!--   temp_cohort_df1$cohortID = paste0(i_c,"_",temp_cohort_df1$cohortID) -->
<!--   temp_cohort_df1$trees_ha = trees -->
<!--   temp_cohort_df1$mean_dbh = dbh -->
<!--   temp_cohort_df1$dbh_shape = dbh_shape -->
<!--   temp_cohort_df1$name = cohort_layers_dt$name[i_c] -->
<!--   cohort_layers1_dt <- rbind(cohort_layers1_dt,temp_cohort_df1) -->
<!-- } -->

<!-- cohort_layers2_dt <- data.table() -->
<!-- counter = 0 -->
<!-- for(sp in 1:nrow(parComp)){ -->
<!--   counter = counter + 1 -->
<!--   temp_cohort_df2 = copy(cohort_layers1_dt) -->
<!--   temp_cohort_df2$siteID = counter -->
<!--   temp_cohort_df2$species = sp -->
<!--   temp_cohort_df2$parCompStr = parCompStr[sp] -->
<!--   cohort_layers2_dt <- rbind(cohort_layers2_dt, temp_cohort_df2) -->
<!-- } -->

<!-- cohort_layers2_dt[,cohortID := as.integer(as.factor(cohortID)), by = siteID] -->
<!-- cohort_layers2_dt$cohortID = as.integer(cohort_layers2_dt$cohortID) -->
<!-- cohort_layers2_dt = cohort_layers2_dt[order(cohortID)] -->

<!-- cohort = CohortMat$new(obs_df = cohort_layers2_dt) -->
<!-- basal_area = BA_stand(cohort$dbh, cohort$trees, patch_size_ha = 1) -->

<!-- light = competition(dbh = cohort$dbh, species = cohort$species, -->
<!--                     trees = cohort$trees, parComp = torch::torch_tensor(parComp), -->
<!--                     h = NULL, patch_size_ha = 1) -->

<!-- for(i_site in unique(cohort_layers2_dt$siteID)){ -->
<!--   cohort_layers2_dt[siteID == i_site, basal_area2 := torch::as_array(basal_area)[i_site,1,1:nrow(cohort_layers2_dt[siteID == i_site])]] -->
<!--   cohort_layers2_dt[siteID == i_site, light2 := torch::as_array(light)[i_site,1,1:nrow(cohort_layers2_dt[siteID == i_site])]] -->
<!-- } -->

<!-- cohort_layers2_dt[,":="(ba = round(sum(basal_area2))), by = .(siteID, name)] -->
<!-- cohort_layers2_dt[,":="(dbh_density = dweibull(dbh,shape = dbh_shape, scale = mean_dbh)), by = .(name)] -->
<!-- cohort_layers2_dt[,name := factor(name, levels = c("understory", "midstory", "overstory"), ordered = T),] -->

<!-- label_dt <- cohort_layers2_dt[,.(mean_dbh = mean(dbh), ba = round(sum(basal_area2)), max_density = max(dbh_density)), by = .(siteID, name)] -->

<!-- p_cohorts = ggplot(cohort_layers2_dt)+ -->
<!--   geom_histogram(aes(x = dbh, fill = name, y = ..density..), alpha = 0.3)+ -->
<!--   geom_line(aes(x = dbh, y = dbh_density, color = name), linewidth = 1)+ -->
<!--   # facet_wrap(~siteID)+ -->
<!--   geom_text(data = label_dt, aes(x = mean_dbh, y = max_density+0.03, label = paste0(name,"\n"," ba = ", ba), color = name), size = 5)+ -->
<!--   guides( -->
<!--     color = guide_legend(title = "layer", override.aes = list(label = "")), -->
<!--     fill = guide_legend(title = "layer") -->
<!--     )+ -->
<!--   xlab("dbh [cm]") + -->
<!--   theme_bw()+ -->
<!--   coord_cartesian(ylim = c(0, max(label_dt$max_density)+0.05))+ -->
<!--   theme(legend.position = "none", axis.text.y = element_blank(), axis.ticks.y = element_blank()) -->

<!-- p_light = ggplot(cohort_layers2_dt)+ -->
<!--   geom_boxplot(aes(x = name, y = light2, color = name), linewidth = 1)+ -->
<!--   facet_wrap(~factor(siteID, levels = 1:3, labels = paste("parCompStr =", c(parComp[,2]))))+ -->
<!--   # add axis labels -->
<!--   xlab("layer") + -->
<!--   ylab("light [%]") + -->
<!--   theme_classic()+ -->
<!--   theme(legend.position = "none", axis.title.x = element_blank()) -->

<!-- gridExtra::grid.arrange( -->
<!--   grobs = list( -->
<!--     label_grob_f("a"), label_grob_f("b"), label_grob_f("c"), label_grob_f("d"), -->
<!--     p_ba, p_height, p_cohorts, p_light -->
<!--   ),  -->
<!--   layout_matrix = rbind( -->
<!--     c(1,2), -->
<!--     c(5,6), -->
<!--     c(3,NA), -->
<!--     c(7,7), -->
<!--     c(4,NA), -->
<!--     c(8,8) -->
<!--   ), -->
<!--   # include letters to each plot -->
<!--   widths = c(0.6,0.6),  -->
<!--   heights = c(0.05,0.95,0.05,0.95,0.05,0.95) -->
<!-- ) -->


<!-- ``` -->


<!-- ## Figure 7 (scaled sigmoids) -->
<!-- ```{r} -->
<!-- #| label: fig-Fig_7 -->
<!-- #| fig-format: pdf -->
<!-- #| fig-width: 11 -->
<!-- #| fig-height: 5 -->
<!-- #| echo: false -->
<!-- #| silent: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-cap: "" -->
<!-- light = seq(0,1,0.01) -->
<!-- regLight = seq(0.1, 0.9, 0.2) -->
<!-- growthLight = regLight -->
<!-- regLight_f <- function(light,regLight, k = 10) { -->
<!--   regP = (1 / (1 + exp(-k * (light - regLight))) - 1 / (1 + exp(k * regLight))) / (1 - 1 / (1 + exp(k * (1 - regLight)))) -->
<!--   return(regP) -->
<!--   } -->
<!-- growthShade_f <- function(light, growthLight, k = 10) { -->
<!--   shade = ((1 / (1 + exp(-k * (light - growthLight))) - 1 / (1 + exp(k * growthLight))) / -->
<!--              (1 / (1 + exp(-k * (1 - growthLight))) - 1 / (1 + exp(k * growthLight)))) -->
<!--   return(shade) -->
<!--   } -->

<!-- reg_dt <-  -->
<!--   data.table( -->
<!--       process = "regeneration", -->
<!--       light = rep(light, length(regLight)), -->
<!--       regLight = factor(rep(regLight, each = length(light)), ordered = T), -->
<!--       response = as.vector(sapply(regLight, function(x) regLight_f(light, x), simplify = TRUE)) -->
<!--     ) -->
<!-- growth_dt <- data.table( -->
<!--       process = "growth", -->
<!--       light = rep(light, length(growthLight)), -->
<!--       growthLight = factor(rep(growthLight, each = length(light)), ordered = T), -->
<!--       response = as.vector(sapply(growthLight, function(x) growthShade_f(light, x), simplify = TRUE)) -->
<!--     ) -->

<!-- reg_p <- ggplot(reg_dt, aes(light, response, colour = regLight)) + -->
<!--   geom_line(size = 1) + -->
<!--   labs(x = "Light", -->
<!--        y = "Scaled light response of (regeneration)") + -->
<!--   theme_classic() -->
<!-- # reg_p -->
<!-- growth_p <- ggplot(growth_dt, aes(light, response, colour = growthLight)) + -->
<!--   geom_line(size = 1) + -->
<!--   labs(x = "Light", -->
<!--        y = "Scaled light response of (growth)") + -->
<!--   theme_classic() -->
<!-- # growth_p -->

<!-- gridExtra::grid.arrange(reg_p+ggtitle("a"), growth_p+ggtitle("b"), ncol = 2) -->
<!-- ``` -->


<!-- ## Appendix -->
<!-- ### emergent patterns -->

<!-- ```{r} -->
<!-- #| label: fig-Fig_emerg_patterns -->
<!-- #| fig-format: pdf -->
<!-- #| fig-width: 9 -->
<!-- #| fig-height: 9 -->
<!-- #| echo: false -->
<!-- #| silent: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-cap: "Annual growth and mortality rates of trees vs. dbh. Observed values (red line) and simulated values from the process model and the hybrid model (cyan line). The lines show fitted gams to the data and visualize how well the simulated patterns match the observed patterns. Note that the observed data only contains 0 and 1 values for mortality while the simulated values show the estimated mortality probability." -->
<!-- # load models -->

<!-- process_m <- torch::torch_load(fitted_models[1]) -->
<!-- hybrid_m <- torch::torch_load(fitted_models[2]) -->
<!-- if(file.exists("figures/emergent-patterns.csv")){ -->
<!--   p_dat <- fread("figures/emergent-patterns.csv") -->
<!-- }else{ -->
<!--   cohort_dt <- fread("data/BCI/noSplits/pft-period7-25patches/initial_cohorts1985.csv") -->
<!--   env_dt <- fread("data/BCI/noSplits/pft-period7-25patches/env_dt.csv") -->
<!--   cohort1 <- CohortMat$new(obs_df = cohort_dt) -->
<!--   plot(process_m$parameters_r$par_regeneration_unconstrained) -->
<!--   obs_trees <- fread("data/BCI/data-cleaning/pft/all_trees.csv") -->

<!--   proc_sim = process_m$simulate(env = env_dt, init_cohort = cohort1, patches = 25, patch_size = 0.1, debug = T) -->
<!--   hybr_sim = hybrid_m$simulate(env = env_dt, init_cohort = cohort1, patches = 25, patch_size = 0.1, debug = T) -->
<!--   proc_dat = data.table(proc_sim$wide$cohort, type = "process") -->
<!--   hybr_dat = data.table(hybr_sim$wide$cohort, type = "hybrid") -->
<!--   obs_dat = obs_trees[census > 1985 & status2 != "regeneration",.( -->
<!--     species, -->
<!--     g = relative_growth_5yr, -->
<!--     m = as.integer(status2 == "died"), -->
<!--     dbh = gdbh_cm_before, -->
<!--     dbh2 = gdbh_cm -->
<!--     )] -->
<!--   # obs_dat <- fread("data/BCI/noSplits/pft-period7-25patches/obs_dt.csv") -->

<!--   p_dat <- rbindlist(list( -->
<!--       data.table(proc_dat, dbh2 = proc_dat$dbh, obs = "simulated"), -->
<!--       data.table(hybr_dat, dbh2 = hybr_dat$dbh, obs = "simulated"), -->
<!--       data.table(obs_dat, obs = "observed", type = "hybrid"), -->
<!--       data.table(obs_dat, obs = "observed", type = "process") -->
<!--       ), fill = T -->
<!--       ) -->
<!--   fwrite(p_dat, "figures/emergent-patterns.csv") -->
<!-- } -->

<!-- p1 = ggplot()+ -->
<!--   geom_point(data = p_dat[dbh >= 1 & obs != "observed"], aes(dbh,(1+m)^(1/5)-1), alpha = 0.3)+ -->
<!--   # geom_rug(data = p_dat[dbh >= 1 & obs == "observed" & m == 1], aes(x = dbh, alpha = 0.001, color = "observed"))+ -->
<!--   geom_smooth( -->
<!--     data = p_dat[dbh >= 1], aes(dbh,(1+m)^(1/5)-1, color = obs), -->
<!--     method = "gam", method.args = list(family = "binomial") -->
<!--     )+ -->
<!--   facet_grid(factor(type, levels = c("observed", "hybrid", "process"), ordered = T)~paste0("PFT = ", species))+ -->
<!--   scale_x_log10()+ -->
<!--   theme_classic()+ -->
<!--   labs(x = "dbh [cm]", y = "Mortality [%/100]") -->
<!-- dbh_cmTOba_m2 <- function(dbh) { -->
<!--   dbh = dbh/100 -->
<!--   return(pi*dbh^2/4) -->
<!--   } -->
<!-- p2 = ggplot()+ -->
<!--   geom_point( -->
<!--     data = p_dat[dbh2 >= 1 & g > 0 & (m != 1|is.na(m)) & obs != "observed"], aes(dbh,(1+g)^(1/5)-1), alpha = 0.3)+ -->
<!--   # geom_rug(data = p_dat[dbh2 >= 1 & obs == "observed" & g > 0 & (m != 1|is.na(m))], aes(x = dbh, alpha = 0.001, color = "observed"))+ -->
<!--   geom_smooth( -->
<!--     data = p_dat[dbh2 >= 1 & g > 0 & (m != 1|is.na(m))], aes(dbh,(1+g)^(1/5)-1, color = obs), -->
<!--     method = "gam", method.args = list(family = "gaussian") -->
<!--     )+ -->
<!--   coord_cartesian(ylim = c(0,NA))+ -->
<!--   facet_grid(factor(type, levels = c("observed", "hybrid", "process"), ordered = T)~paste0("PFT = ", species))+ -->
<!--   scale_x_log10()+ -->
<!--   theme_classic()+ -->
<!--   labs(x = "dbh [cm]", y = "Growth [%/100]") -->
<!-- p3 = ggplot()+ -->
<!--   # geom_point( -->
<!--   #   data = p_dat[dbh2 >= 1 & g > 0 & (m != 1|is.na(m)) & obs != "observed"], -->
<!--   #   aes(dbh_cmTOba_m2(dbh),dbh_cmTOba_m2(dbh*((g)^(1/5)-1))), alpha = 0.3)+ -->
<!--   # geom_rug(data = p_dat[dbh2 >= 1 & obs == "observed" & g > 0 & (m != 1|is.na(m))], aes(x = dbh, alpha = 0.001, color = "observed"))+ -->
<!--   geom_smooth( -->
<!--     data = p_dat[dbh2 >= 1 & g > 0 & (m != 1|is.na(m))], -->
<!--     aes(dbh,dbh_cmTOba_m2(dbh*((g-1))), color = obs), -->
<!--     method = "gam", method.args = list(family = "gaussian"), se = F -->
<!--     )+ -->
<!--   coord_cartesian(ylim = c(0,NA))+ -->
<!--   facet_grid(factor(type, levels = c("observed", "hybrid", "process"), ordered = T)~paste0("PFT = ", species))+ -->
<!--   # scale_x_log10()+ -->
<!--   theme_classic()+ -->
<!--   labs(x = "dbh [cm]", y = "BAI [m2]") -->
<!-- max_dt <- p_dat[,.(max(dbh,na.rm = T)),by = .(species,obs)] -->

<!-- p4 = ggplot()+ -->
<!--   # geom_point( -->
<!--   #   data = p_dat[dbh2 >= 1 & g > 0 & (m != 1|is.na(m)) & obs != "observed"], -->
<!--   #   aes(dbh_cmTOba_m2(dbh),dbh_cmTOba_m2(dbh*((g)^(1/5)-1))), alpha = 0.3)+ -->
<!--   # geom_rug(data = p_dat[dbh2 >= 1 & obs == "observed" & g > 0 & (m != 1|is.na(m))], aes(x = dbh, alpha = 0.001, color = "observed"))+ -->
<!--   geom_smooth( -->
<!--     data = p_dat[dbh2 >= 1 & g > 0 & (m != 1|is.na(m))], -->
<!--     aes(dbh_cmTOba_m2(dbh),dbh_cmTOba_m2(dbh*((g-1))), color = obs), -->
<!--     method = "gam", method.args = list(family = "gaussian"), se = F -->
<!--     )+ -->
<!--   coord_cartesian(ylim = c(0,NA))+ -->
<!--   facet_grid(factor(type, levels = c("observed", "hybrid", "process"), ordered = T)~paste0("PFT = ", species))+ -->
<!--   # scale_x_log10()+ -->
<!--   theme_classic()+ -->
<!--   labs(x = "basal area [m2]", y = "BAI [m2]") -->
<!-- max_dt <- p_dat[,.(max(dbh,na.rm = T)),by = .(species,obs)] -->


<!-- leg_p <- get_legend(p1+theme(legend.title = element_blank())) -->
<!-- grid.arrange(grobs = list( -->
<!--   p1+ggtitle("a")+theme(legend.position = "none"), -->
<!--   p2+ggtitle("b")+theme(legend.position = "none"), -->
<!--   p3+ggtitle("b")+theme(legend.position = "none"), -->
<!--   leg_p -->
<!--   ), -->
<!--   layout_matrix = rbind( -->
<!--     c(1,4), -->
<!--     c(2,4), -->
<!--     c(3,4) -->
<!--   ), widths = c(0.9,0.1), heights = c(0.5,.5,0.5)) -->

<!-- ``` -->


<!-- ### response correlations -->

<!-- ```{r} -->
<!-- #| label: fig-Fig_response-cors -->
<!-- #| fig-format: pdf -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 5 -->
<!-- #| echo: false -->
<!-- #| silent: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-cap: "Spearman correlations from five fold patial cross validation to asses how well a model can be trained with different combinations of response variables. To ensure a full coverage of each response variable, we simulated new data from the process model that was trained on the BCI forest inventory data. These simulations were used to calibrate models with different combinations of response variables. The correlations were derived as average from a spatially blocked five-fold cross validation." -->

<!-- cors_fullPlot = fread("results/cors_fullPlot.csv") -->
<!-- cors_fullPlotSpecies <- fread("results/cors_fullPlotSpecies.csv") -->


<!-- all_cors <- rbind( -->
<!--   data.table(cors_fullPlot, species = "all"), -->
<!--   cors_fullPlotSpecies -->
<!-- ) -->

<!-- p_cors <- cors_fullPlot[hybrid == "nohybrid"] -->
<!-- # p_cors <- cors_fullPlot[hybrid == "nohybrid"] -->

<!-- p_cors2 <- p_cors[cv != "T0S0",.( -->
<!--   r = mean(spearmans_r), -->
<!--   nresponses = length(tstrsplit(response, ".", fixed = TRUE)) -->
<!--   # nresponses = tstrsplit(response, ".", fixed = TRUE)[[1]] -->
<!--   ), by = .(variable,response=gsub(".pt","",response),scale, test_train,simreal)] -->


<!-- ggplot(p_cors2[grepl("pft", scale) & simreal == "simulated"],aes(x = variable, y = forcats::fct_reorder(response, -nresponses), fill = r)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, limits = c(-1,1)) + -->
<!--   labs(x = "Predicted Variable", y = "Loss Variables", fill = "Spearmans Correlation") + -->
<!--   theme_classic() + -->
<!--   facet_grid(test_train~scale, )+ -->
<!--   theme(axis.text.x = element_text(angle = 45, hjust = 1)) -->
<!-- ``` -->

<!-- ### hybrid model correlations -->

<!-- ```{r} -->
<!-- #| label: fig-Fig_hybridvariant-cors -->
<!-- #| fig-format: pdf -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 7 -->
<!-- #| echo: false -->
<!-- #| silent: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-cap: "Performance of different hybrid modeling architecture and calibration setups. Each hybrid model was trained on the observed BCI forest inventory data. The spearman correlations represents the average from a spatially blocked five-fold cross validation." -->
<!-- cors_fullPlot = fread("results/cors_fullPlot.csv") -->
<!-- cors_fullPlotSpecies <- fread("results/cors_fullPlotSpecies.csv") -->
<!-- p_cors <- cors_fullPlot[response == "ba.trees.dbh.growth.mort.reg.pt" | response == ""] -->

<!-- p_cors2 <- p_cors[cv != "S0T0",.( -->
<!--   r = mean(spearmans_r, na.rm = T), -->
<!--   nresponses = length(tstrsplit(response, ".", fixed = TRUE)) -->
<!--   # nresponses = tstrsplit(response, ".", fixed = TRUE)[[1]] -->
<!--   ), by = .(variable, scale, test_train,simreal, hybrid)] -->


<!-- p_pft <- ggplot(p_cors2[grepl("pft", scale) & simreal == "real"],aes(x = variable, y = hybrid, fill = r)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, limits = c(-1,1)) + -->
<!--   labs(x = "Predicted Variable", y = "Loss Variables", fill = "Spearmans Correlation") + -->
<!--   theme_classic() + -->
<!--   facet_grid(test_train~scale)+ -->
<!--   theme(axis.text.x = element_text(angle = 45, hjust = 1)) -->

<!-- p_genus <- ggplot(p_cors2[grepl("genus", scale) & simreal == "real"],aes(x = variable, y = hybrid, fill = r)) + -->
<!--   geom_tile() + -->
<!--   scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, limits = c(-1,1)) + -->
<!--   labs(x = "Predicted Variable", y = "Loss Variables", fill = "Spearmans Correlation") + -->
<!--   theme_classic() + -->
<!--   facet_grid(test_train~scale)+ -->
<!--   theme(axis.text.x = element_text(angle = 45, hjust = 1)) -->

<!-- grid.arrange( -->
<!--   grobs = list( -->
<!--     p_pft+ggtitle("a"), p_genus+ggtitle("b") -->
<!--   ), -->
<!--   layout_matrix = rbind( -->
<!--     c(1), -->
<!--     c(2) -->
<!--   ), -->
<!--   heights = c(0.6,0.4), widths = c(1) -->
<!-- ) -->

<!-- ``` -->


<!-- ### fitted parameters -->

<!-- ```{r} -->
<!-- #| label: fig-Fig_fitted_parameters -->
<!-- #| fig-format: pdf -->
<!-- #| fig-width: 10 -->
<!-- #| fig-height: 8 -->
<!-- #| echo: false -->
<!-- #| silent: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-cap: "Estimated parameters for process-FINN and hybrid-FINN calibrated on the BCI forest inventory data." -->

<!-- models_process = list.files("results/02_realdata/", full.names = T, recursive = T, pattern = "pft-period7-25patches_S0_T0") -->
<!-- models_hybrid = list.files("results/02_realdata_hybridTF0/", full.names = T, recursive = T, pattern = "pft-period7-25patches_S0_T0") -->
<!-- m_true_process = torch::torch_load(models_process) -->
<!-- m_true_hybrid = torch::torch_load(models_hybrid) -->

<!-- par_df = data.table() -->
<!-- par_names = c("par_competition_r", "par_growth_r", "par_mortality_r", "par_regeneration_r") -->
<!-- for(i in par_names){ -->
<!--   for(c in 1:ncol(m_true_process[[i]])){ -->
<!--     par_df = rbind( -->
<!--       par_df, -->
<!--       data.table( -->
<!--         true_process = m_true_process[[i]][,c], -->
<!--         true_hybrid = m_true_hybrid[[i]][,c], -->
<!--         par = paste0(i,c), -->
<!--         species = 1:length(m_true_process[[i]][,c]) -->
<!--         ) -->
<!--       ) -->
<!--   } -->
<!-- } -->

<!-- par_names_nn = c("nn_mortality.0.weight", "nn_growth.0.weight", "nn_regeneration.0.weight") -->
<!-- for(i in par_names_nn){ -->
<!--   for(c in 1:ncol(m_true_process$parameters_r[[i]])){ -->
<!--     par_df = rbind( -->
<!--       par_df, -->
<!--       data.table( -->
<!--         true_process = m_true_process$parameters_r[[i]][,c], -->
<!--         true_hybrid = m_true_hybrid$parameters_r[[i]][,c], -->
<!--         par = paste0(i,c), -->
<!--         species = 1:length(m_true_process$parameters_r[[i]][,c]) -->
<!--         ), fill = TRUE -->
<!--     ) -->
<!--   } -->
<!-- } -->

<!-- par_df[grepl("competition",par),process := "competition",] -->
<!-- par_df[grepl("competition_r1",par),name := "compHeight",] -->
<!-- par_df[grepl("competition_r2",par),name := "compStr",] -->
<!-- par_df[grepl("growth",par),process := "growth",] -->
<!-- par_df[grepl("growth_r1",par),name := "growthLight",] -->
<!-- par_df[grepl("growth_r2",par),name := "growthSize",] -->
<!-- par_df[grepl("mortality",par),process := "mortality",] -->
<!-- par_df[grepl("mortality_r1",par),name := "mortLight",] -->
<!-- par_df[grepl("mortality_r2",par),name := "mortSize",] -->
<!-- par_df[grepl("mortality_r3",par),name := "mortGrowth",] -->
<!-- par_df[grepl("regeneration",par),process := "regeneration",] -->
<!-- par_df[grepl("regeneration_r1",par),name := "regLight",] -->
<!-- par_df[grepl("par",par),type := "process parameter",] -->
<!-- par_df[grepl("nn_",par),type := "environment parameter",] -->

<!-- par_df[type == "environment parameter",name := gsub("weight","",tstrsplit(par, ".", fixed = T)[[3]]),] -->

<!-- # make "intercept" allways the first -->
<!-- par_df[,name := factor(name, levels = c("intercept", unique(par_df[name != "intercept"]$name))),] -->

<!-- p_dat <- melt(par_df, id.vars = c("name", "process", "species", "type"), -->
<!--                  measure.vars = c("true_process", "true_hybrid"), -->
<!--                  variable.name = "true", value.name = "value") -->

<!-- p_dat[,model := gsub("true_","",true),] -->

<!-- p_dat[,species2 := factor(species, levels = 1:5, labels = names(pft_cols)),] -->

<!-- p_proc_comp <- ggplot( -->
<!--   p_dat[type == "process parameter" & process == "competition"], -->
<!--   aes(x = name, y = value, color = factor(model), fill = factor(model)) -->
<!--   ) + -->
<!--   geom_hline(yintercept = 0)+ -->
<!--   facet_wrap(process~paste0(species2), ncol = 5, scales = "fixed") + -->
<!--   theme_classic()+ -->
<!--   geom_bar(width = 0.2, outlier.shape = NA, stat = "identity", position = position_dodge())+ -->
<!--   theme(axis.title.x = element_blank()) -->
<!-- p_proc_growth <- ggplot( -->
<!--   p_dat[type == "process parameter" & process == "growth" & model == "process"], -->
<!--   aes(x = name, y = value, -->
<!--       color = factor(model, levels = c("hybrid", "process")), -->
<!--       fill = factor(model, levels = c("hybrid", "process"))) -->
<!--   ) + -->
<!--     geom_hline(yintercept = 0)+ -->
<!--   scale_color_manual(values = c("process" = "#00BFC4"))+ -->
<!--   scale_fill_manual(values = c("process" = "#00BFC4"))+ -->
<!--   facet_wrap(process~paste0(species2), ncol = 5, scales = "fixed") + -->
<!--   theme_classic()+ -->
<!--   geom_bar(width = 0.2, outlier.shape = NA, stat = "identity", position = position_dodge())+ -->
<!--   theme(axis.title.x = element_blank()) -->
<!-- p_proc_mort <- ggplot( -->
<!--   p_dat[type == "process parameter" & process == "mortality"], -->
<!--   aes(x = name, y = value, color = factor(model), fill = factor(model)) -->
<!--   ) + -->
<!--     geom_hline(yintercept = 0)+ -->
<!--   facet_wrap(process~paste0(species2), ncol = 5, scales = "fixed") + -->
<!--   theme_classic()+ -->
<!--   geom_bar(width = 0.2, outlier.shape = NA, stat = "identity", position = position_dodge())+ -->
<!--   theme(axis.title.x = element_blank()) -->
<!-- p_proc_reg <- ggplot( -->
<!--   p_dat[type == "process parameter" & process == "regeneration"], -->
<!--   aes(x = name, y = value, color = factor(model), fill = factor(model)) -->
<!--   ) + -->
<!--     geom_hline(yintercept = 0)+ -->
<!--   facet_wrap(process~paste0(species2), ncol = 5, scales = "fixed") + -->
<!--   theme_classic()+ -->
<!--   geom_bar(width = 0.2, outlier.shape = NA, stat = "identity", position = position_dodge())+ -->
<!--   theme(axis.title.x = element_blank()) -->

<!-- p_proc_legend <- get_legend(p_proc_comp+theme(legend.position = "bottom")+guides(color = guide_legend(title = "Model"), fill = guide_legend(title = "Model"))) -->
<!-- # arrange in three columns -->

<!-- fac_levels = c("intercept","Prec","SR_kW_m2","RH_prc","T_max","T_min","swp") -->

<!-- p_env <- ggplot( -->
<!--   p_dat[type == "environment parameter"], -->
<!--        aes(x = factor(name, levels = 1:7, labels = fac_levels), y = value, color = factor(model), fill = factor(model)) -->
<!--   ) + -->
<!--   geom_hline(yintercept = 0)+ -->
<!--   facet_wrap(process~paste0(species2), ncol = 5, scales = "free_x") + -->
<!--   labs(x = "Parameter", y = "Difference")+ -->
<!--   theme_classic()+ -->
<!--   geom_bar(width = 0.7, outlier.shape = NA, stat = "identity", position = position_dodge2(width = 1.5, padding = 0.2, preserve = "single"))+ -->
<!--   theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1)) -->


<!-- grid.arrange( -->
<!--   grobs = list( -->
<!--     p_proc_comp+theme(legend.position = "none", axis.title.y = element_blank()), -->
<!--     p_proc_growth+theme(legend.position = "none", axis.title.y = element_blank()), -->
<!--     p_proc_mort+theme(legend.position = "none", axis.title.y = element_blank()), -->
<!--     p_proc_reg+theme(legend.position = "none", axis.title.y = element_blank()), -->
<!--     p_proc_legend -->
<!--   ), -->
<!--   layout_matrix = rbind( -->
<!--     c(1), -->
<!--     c(2), -->
<!--     c(3), -->
<!--     c(4), -->
<!--     c(5) -->
<!--   ), -->
<!--   # include letters to each plot -->
<!--   heights = c(0.6,0.6,0.6,0.6,0.1), -->
<!-- ) -->

<!-- grid.arrange( -->
<!--   grobs = list( -->
<!--     p_env+theme(legend.position = "none", axis.title.y = element_blank()), -->
<!--     p_proc_legend -->
<!--   ), -->
<!--   layout_matrix = rbind( -->
<!--     c(1), -->
<!--     c(2) -->
<!--   ), -->
<!--   # include letters to each plot -->
<!--   heights = c(0.6*3.2,0.1), -->
<!-- ) -->


<!-- # gridExtra::grid.arrange( -->
<!-- #   grobs = list( -->
<!-- #     label_grob_f("a"), label_grob_f("b"), -->
<!-- #     p_proc, p_env -->
<!-- #   ), -->
<!-- #   layout_matrix = rbind( -->
<!-- #     c(1,2), -->
<!-- #     c(3,4) -->
<!-- #   ), -->
<!-- #   # include letters to each plot -->
<!-- #   widths = c(0.6,0.6), -->
<!-- #   heights = c(0.05,0.95) -->
<!-- # ) -->

<!-- ``` -->

<!-- ### Spatial holdout -->
<!-- ```{r} -->
<!-- #| label: fig-Fig_spatial_folds -->
<!-- #| fig-format: pdf -->
<!-- #| fig-width: 8 -->
<!-- #| fig-height: 3 -->
<!-- #| echo: false -->
<!-- #| silent: true -->
<!-- #| message: false -->
<!-- #| warning: false -->
<!-- #| fig-cap: "Spatial holdout folds used for the spatial cross validation." -->

<!-- spatial_folds_dt <- fread("data/BCI/noSplits/pft-period7-25patches/spatial_folds_dt.csv") -->
<!-- swp_dt <- fread("data/BCI/noSplits/pft-period7-25patches/swp_dt.csv") -->
<!-- spatial_folds_dt = merge(spatial_folds_dt, swp_dt, by = c("siteID")) -->
<!-- p_spatial2 = ggplot(spatial_folds_dt, aes(x = x_class, y = y_class, fill = factor(spatial_fold))) + -->
<!--   geom_tile()+ -->
<!--   theme_minimal() + -->
<!--   labs(title = "Spatial Folds", color = "Fold")+ -->
<!--   # facet_wrap(~factor(fold)) + -->
<!--   guides(fill = guide_legend(title = "fold"))+ -->
<!--   xlab("X")+ -->
<!--   ylab("Y")+ -->
<!--   coord_fixed() -->

<!-- p_spatial2 -->

<!-- ``` -->

